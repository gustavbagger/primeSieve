package main

import (
	"fmt"
	"math"

	pr "github.com/fxtlabs/primes"
)

func printIntervals(omegaMax, omegaMin int) {
	//careful here, we need len(primeList)>= omega
	primeList := pr.Sieve(1000)
	for omega := omegaMax; omega >= omegaMin; omega-- {
		sBest := 0
		deltaBest := 1.0
		currentBest := float64(int(1) << (omega + 1))
		for s := 1; s <= omega; s++ {
			delta := deltaSum(primeList[omega-s : omega])
			if delta <= 0.0 {
				break
			}
			currentTry := (2.0 + float64(s-1)/delta) * float64(int(1)<<(omega+1-s))
			if currentTry < currentBest {
				currentBest = currentTry
				sBest = s
				deltaBest = delta
			}
		}
		var sum float64
		for _, p := range primeList[:omega] {
			sum += math.Log(float64(p))
		}

		fmt.Printf(
			"%5.1e>p>%5.1e ---- o,s,d = %v,%v,%2.2f\n",
			math.Pow(currentBest, 16),
			math.Pow(math.E, sum),
			omega,
			sBest,
			deltaBest,
		)

	}
}

var totalTopLevel int
var doneTopLevel int
var nextPercent int

func search(omega, a, b int) {

	boundLog := math.Log(float64(a) * math.Pow10(b))
	primeList := pr.Sieve(5000)
	logs := make([]float64, len(primeList))

	for i, p := range primeList {
		logs[i] = math.Log(float64(p))
	}

	initBestS(omega, primeList)

	maxIndex := len(primeList) - 1
	indexes := make([]int, omega)

	totalTopLevel = maxIndex - (omega - 1)
	doneTopLevel = 0
	nextPercent = 1

	recursiveLoop(
		0,
		omega,
		maxIndex,
		boundLog,
		indexes,
		primeList,
		logs,
		0.0,
	)
	fmt.Println("--------------------------------------------")
}
package main

import (
	"fmt"
	"math/big"
)

func deltaSum(list []int) float64 {
	var sum float64
	for _, p := range list {
		sum -= 1.0 / float64(p)
	}
	return sum + 1
}

func Prod(list []int) *big.Int {
	prod := big.NewInt(1)
	for _, p := range list {
		prod.Mul(prod, big.NewInt(int64(p)))
	}
	return prod
}

func indexesToValues(indexes, allValues []int) []int {
	output := make([]int, len(indexes))
	for i, index := range indexes {
		output[i] = allValues[index]
	}
	return output
}

func treeSearch(
	position int,
	omega int,
	currentLog, boundLog float64,
	indexes, allValues []int,
	logs []float64,
	exponents []int,
	modState *ModState,
) {
	if position == omega {

		if !modState.isInvalid() && validExponentSet(indexes, exponents, allValues) {
			fmt.Println("--------------------------------------------")
			fmt.Printf("%v\n", indexesToValues(indexes, allValues))
		}
		return
	}

	optSieveBound := optSieveBoundLog(omega, indexes, allValues, boundLog)

	if currentLog > optSieveBound {
		return
	}

	index := indexes[position]
	//p := allValues[index]
	logp := logs[index]

	e := 1
	logAcc := currentLog + logp
	for logAcc <= optSieveBound {
		exponents[position] = e

		newMod := &ModState{mods: append([]int{}, modState.mods...)}
		newMod.pushPrimeExp(allValues[index], e)

		//bail early if we know this path can't yield a valid tuple
		if newMod.isInvalid() {
			e++
			logAcc += logp
			continue
		}

		treeSearch(
			position+1,
			omega,
			logAcc,
			boundLog,
			indexes,
			allValues,
			logs,
			exponents,
			newMod,
		)
		e++
		logAcc += logp
	}
}

func canComplete(
	boundLog float64,
	currentLog float64,
	nextIndex int,
	remaining int,
	logs []float64,
) bool {
	// Not enough primes left to complete the tuple
	if nextIndex+remaining > len(logs) {
		return false
	}

	// sum logs of the next `remaining` smallest primes starting at nextIndex
	var future float64
	for i := 0; i < remaining; i++ {
		future += logs[nextIndex+i]
	}
	return currentLog+future <= boundLog
}

type Status int

const (
	Continue Status = iota
	Backtrack
	Stop
)

func recursiveLoop(
	currentDepth, maxDepth, maxIndex int,
	boundLog float64,
	indexes, primeList []int,
	logs []float64,
	currentLog float64,
) Status {

	if currentDepth == maxDepth {
		indexesCopy := append([]int{}, indexes...)
		exponents := make([]int, maxDepth)
		modState := newModState()
		treeSearch(
			0,
			maxDepth,
			0,
			boundLog,
			indexesCopy,
			primeList,
			logs,
			exponents,
			modState,
		)
		return Continue
	}
	startIndex := 0
	if currentDepth > 0 {
		startIndex = indexes[currentDepth-1] + 1
	}

	limit := maxIndex - (maxDepth - currentDepth) + 1
	for i := startIndex; i < limit; i++ {

		if currentDepth == 0 {
			doneTopLevel++
			percent := 100 * doneTopLevel / totalTopLevel
			if percent >= nextPercent {
				fmt.Printf("Progress: %v%%\n", percent)
				nextPercent += 1
			}

		}

		indexes[currentDepth] = i

		newLog := currentLog + logs[i]

		remainingDepth := maxDepth - (currentDepth + 1)
		nextIndex := i + 1

		if !canComplete(boundLog, newLog, nextIndex, remainingDepth, logs) {
			continue
		}
		indexesCopy := append([]int{}, indexes...)

		status := recursiveLoop(
			currentDepth+1,
			maxDepth,
			maxIndex,
			boundLog,
			indexesCopy,
			primeList,
			logs,
			newLog,
		)

		switch status {
		case Continue, Backtrack:
			continue
		case Stop:
			return Stop
		}
	}
	return Backtrack
}
package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	switch len(os.Args) {
	case 2:
		a, err := strconv.Atoi(os.Args[1])
		if err != nil {
			return
		}
		fmt.Println("omega intervals:")
		printIntervals(a, a)
	case 3:
		a, err := strconv.Atoi(os.Args[1])
		if err != nil {
			return
		}
		b, err := strconv.Atoi(os.Args[2])
		if err != nil {
			return
		}
		fmt.Println("omega intervals:")
		printIntervals(a, b)
	case 4:
		a, err := strconv.Atoi(os.Args[1])
		if err != nil {
			return
		}
		b, err := strconv.Atoi(os.Args[2])
		if err != nil {
			return
		}
		c, err := strconv.Atoi(os.Args[3])
		if err != nil {
			return
		}
		fmt.Printf("searching for omega = %v below %v*10^%v:\n", a, b, c)
		search(a, b, c)
	default:
		fmt.Println("wrong args")
	}
}
package main

import "math"

var bestS []int

func initBestS(omegaMax int, primeList []int) {
	bestS = make([]int, omegaMax+1)
	for omega := 1; omega <= omegaMax; omega++ {
		sBest := 0
		currentBest := float64(int(1) << (omega + 1))
		for s := 1; s <= omega; s++ {
			delta := deltaSum(primeList[omega-s : omega])
			if delta <= 0.0 {
				break
			}
			currentTry := (2.0 + float64(s-1)/delta) * float64(int(1)<<(omega+1-s))
			if currentTry < currentBest {
				currentBest = currentTry
				sBest = s
			}
		}
		bestS[omega] = sBest
	}
}

func optSieveBoundLog(omega int, indexes, primeList []int, boundLog float64) float64 {
	s := bestS[omega]
	if s == 0 || len(indexes) < s {
		return boundLog
	}
	return math.Min(boundLog, pSieveLog(omega, s, indexes, primeList))
}

func pSieveLog(omega, s int, indexes, primeList []int) float64 {
	last := make([]int, s)
	for i := 0; i < s; i++ {
		last[i] = primeList[indexes[omega-s+i]]
	}
	delta := deltaSum(last)
	if delta <= 0.0 {
		return 0.0
	}
	return 16 * (math.Log(2*delta+float64(s-1)) + float64(omega+1-s)*math.Log(2.0) - math.Log(delta))
}
package main

import "math/big"

var smallPrimes = []int{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}

type ModState struct {
	mods []int
}

func newModState() *ModState {
	m := &ModState{
		mods: make([]int, len(smallPrimes)),
	}
	for i := range m.mods {
		m.mods[i] = 1
	}
	return m
}

func (m *ModState) pushPrimeExp(p, e int) {
	for i, sp := range smallPrimes {
		pe := 1
		base := p % sp
		for k := 0; k < e; k++ {
			pe = (pe * base) % sp
		}
		m.mods[i] = (m.mods[i] * pe) % sp
	}
}

func (m *ModState) isInvalid() bool {
	for i, q := range smallPrimes {
		if m.mods[i] == q-1 {
			return true
		}
	}
	return false
}

func validExponentSet(indexes, exponents, allValues []int) bool {
	prod := big.NewInt(1)
	for i, index := range indexes {
		p := big.NewInt(int64(allValues[index]))
		prod.Mul(prod, new(big.Int).Exp(p, big.NewInt(int64(exponents[i])), nil))
	}
	prod.Add(prod, big.NewInt(1))
	return prod.ProbablyPrime(32)
}
